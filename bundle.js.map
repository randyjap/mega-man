{"version":3,"sources":["webpack:///webpack/bootstrap 6bcdf82ed95269a1afa4","webpack:///./entry.js","webpack:///./lib/game.js","webpack:///./lib/vector_util.js","webpack:///./lib/sprites.js","webpack:///./lib/levels.js","webpack:///./lib/canvas.js","webpack:///./lib/sound.js","webpack:///./~/howler/dist/howler.js"],"names":["document","addEventListener","window","pause","music_counter","muteStatus","play","runGame","restartButton","getElementById","e","preventDefault","innerHTML","canvas","cancelAnimationFrame","animation","body","removeChild","muteButton","mute","nextButton","stop","arrowCodes","Game","plan","soundSprites","music","grid","sprites","width","length","height","sound","gameStatus","score","y","row","transformedRow","x","chr","fieldType","Sprite","characters","push","megaman","filter","player","type","boss","prototype","findCollision","pos","size","left","Math","floor","right","ceil","top","bottom","findOverlappingObject","i","other","maxStep","animate","step","keys","thisStep","min","forEach","act","spriteOverlapAction","sprite","hitPoints","hit","round","random","trackKeys","codes","pressed","handler","event","hasOwnProperty","keyCode","down","runAnimation","frameFunc","lastTime","frame","time","timeStep","requestAnimationFrame","arrows","start","level","Canvas","display","drawFrame","plans","VectorUtil","plus","times","factor","Henchman","Boss","Bullet","Megaman","gravity","jumpSpeed","megamanXSpeed","bossFiringRate","megamanFiringRate","speed","lastFire","Date","destroyed","moveY","game","motion","newPos","collidedObject","cFire","fireRight","otherSprite","bulletType","facingRight","moveX","up","shoot","levels","spriteSize","spriteRoll","createElement","src","flipHorizontally","context","around","translate","scale","parent","id","innerWidth","appendChild","cx","getContext","animationTime","viewport","clear","parentNode","updateViewport","clearDisplay","drawBackground","drawSprites","view","margin","center","max","fillStyle","fillRect","xPosition","yPosition","spriteFrameNumber","drawImage","farewellMessage","messageNumber","drawMegaMan","rectangle","Path2D","rect","stroke","save","restore","drawBoss","drawHenchman","henchman","drawBullet","musicChibi","autoplay","loop","volume","musicDigital","musicResistors","victory","explosion","enemyDamage","megamanHurt","jump"],"mappings":"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AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,wDAAuD;;AAEvD;AACA;AACA;;AAEA;AACA,8EAA6E;AAC7E;AACA,kDAAiD;AACjD,iDAAgD;AAChD,iDAAgD;AAChD,iDAAgD;AAChD,iDAAgD;AAChD,mDAAkD;AAClD,oDAAmD,uCAAuC,uCAAuC;AACjI,oDAAmD,uCAAuC,uCAAuC;AACjI,mDAAkD;AAClD,mDAAkD;AAClD,mDAAkD;AAClD,sDAAqD,wCAAwC;AAC7F;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,sBAAsB;AACzC;AACA,wBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,YAAY;AAC5C,mCAAkC,aAAa;AAC/C,mCAAkC,aAAa;AAC/C,6CAA4C,kBAAkB;AAC9D,qCAAoC,cAAc;AAClD,mCAAkC,aAAa;AAC/C,mCAAkC,aAAa;AAC/C,mCAAkC,aAAa;AAC/C,uCAAsC,eAAe;AACrD,mCAAkC,aAAa;AAC/C,mCAAkC,aAAa;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,KAAK;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,cAAc;AAC9B,iBAAgB,QAAQ;AACxB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA,oBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,QAAQ;AACxB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA,oBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,QAAQ;AACxB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,aAAa;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,cAAc;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,aAAa;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,2BAA2B,IAAI,eAAe;AAC1E;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,MAAM;AACvC;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,MAAM;AACtB,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;;AAEA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,uBAAuB;AACtC;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,MAAM;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,MAAM;AACtB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,gDAAgD,EAAE;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAkB,GAAG;AACrB;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc,YAAY;AAC1B,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA,eAAc,KAAK;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,0CAA0C;AAC7C;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,cAAc;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC,MAAM;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC,eAAe;AACrD,iCAAgC,YAAY;AAC5C,iDAAgD,oBAAoB;;AAEpE;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,WAAW;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,WAAW;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,eAAc,SAAS;AACvB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,eAAc,MAAM;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6bcdf82ed95269a1afa4","import { play } from './lib/game.js';\nimport { levels } from './lib/levels.js';\nimport { Canvas } from './lib/canvas.js';\nimport { music, soundSprites } from './lib/sound.js';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  window.pause = false;\n  let music_counter = 0;\n  let muteStatus = false;\n  music[music_counter].play();\n\n  let runGame = play(levels, Canvas, soundSprites, music);\n  runGame();\n  let restartButton = document.getElementById(\"restart\");\n  restartButton.addEventListener(\"click\", e => {\n    e.preventDefault();\n    document.getElementById(\"score\").innerHTML = `Score: 0`;\n    let canvas = document.getElementById(\"canvas\");\n    if (canvas) {\n      cancelAnimationFrame(window.animation);\n      document.body.removeChild(canvas);\n      runGame = play(levels, Canvas, soundSprites, music);\n      runGame();\n    } else {\n      runGame = play(levels, Canvas, soundSprites, music);\n      runGame();\n    }\n  });\n\n  let pause = document.getElementById(\"pause\");\n  pause.addEventListener(\"click\", e => {\n    e.preventDefault();\n    window.pause = !window.pause;\n    if (!window.pause) runGame();\n  });\n\n  let muteButton = document.getElementById(\"mute\");\n  muteButton.addEventListener(\"click\", e => {\n    e.preventDefault();\n    muteStatus = !muteStatus;\n    music[music_counter].mute(muteStatus);\n    soundSprites.mute(muteStatus);\n  });\n\n  let nextButton = document.getElementById(\"nextSong\");\n  nextButton.addEventListener(\"click\", e => {\n    e.preventDefault();\n    music[music_counter].stop();\n    music_counter = (music_counter + 1) % 3;\n    music[music_counter].play();\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./entry.js","import { VectorUtil } from './vector_util';\nimport { Boss, Bullet, Megaman, Henchman } from './sprites';\n\nlet arrowCodes = { 65: \"left\", 87: \"up\", 68: \"right\", 32: \"shoot\" };\n\nfunction Game(plan, soundSprites, music) {\n  this.grid = [];\n  this.sprites = [];\n  this.width = plan[0].length;\n  this.height = plan.length;\n  this.sound = soundSprites;\n  this.music = music;\n  this.gameStatus = null;\n  this.score = 0;\n\n  for (let y = 0; y < this.height; y++) {\n    let row = plan[y], transformedRow = [];\n    for (let x = 0; x < this.width; x++) {\n      let chr = row[x];\n      let fieldType = null;\n      let Sprite = characters[chr];\n      if (Sprite)\n        this.sprites.push(new Sprite(new VectorUtil(x, y), chr));\n      else if (chr === \"#\")\n        fieldType = \"block\";\n      else if (chr === \"W\")\n        fieldType = \"water\";\n      transformedRow.push(fieldType);\n    }\n    this.grid.push(transformedRow);\n  }\n\n  this.megaman = this.sprites.filter(player => {\n    return player.type === \"megaman\";\n  })[0];\n\n  this.boss = this.sprites.filter(player => {\n    return player.type === \"boss\";\n  })[0];\n}\n\nlet characters = {\n  \"M\": Megaman,\n  \"B\": Boss,\n  \"H\": Henchman\n};\n\nGame.prototype.findCollision = function(pos, size) {\n  let left = Math.floor(pos.x);\n  let right = Math.ceil(pos.x + size.x);\n  let top = Math.floor(pos.y);\n  let bottom = Math.ceil(pos.y + size.y);\n\n  if (left < 0 || right > this.width || top < 0) return \"block\";\n\n  for (let y = top; y < bottom; y++) {\n    for (let x = left; x < right; x++) {\n      let fieldType = this.grid[y][x];\n      if (fieldType) return fieldType;\n    }\n  }\n};\n\nGame.prototype.findOverlappingObject = function(player) {\n  for (let i = 0; i < this.sprites.length; i++) {\n    let other = this.sprites[i];\n    if (other !== player &&\n      player.pos.x + player.size.x > other.pos.x &&\n      player.pos.x < other.pos.x + other.size.x &&\n      player.pos.y + player.size.y > other.pos.y &&\n      player.pos.y < other.pos.y + other.size.y)\n    return other;\n  }\n};\nlet maxStep = 0.04;\n\nGame.prototype.animate = function(step, keys) {\n  while (step > 0) {\n    let thisStep = Math.min(step, maxStep);\n    this.sprites.forEach(function(player) {\n      player.act(thisStep, this, keys);\n    }, this);\n    step -= thisStep;\n  }\n};\n\nGame.prototype.spriteOverlapAction = function(type, player, sprite) {\n  if (type === \"water\" && this.gameStatus === null) {\n    if (this.megaman.hitPoints > 0) this.megaman.hitPoints -= 0.3;\n    this.sound.play(\"megamanHurt\");\n    if (this.megaman.hitPoints <= 0) {\n      this.gameStatus = \"lost\";\n    }\n    this.megaman.hit = true;\n  } else if (type === \"friendly-bullet\" && sprite && sprite.type === \"boss\" && this.gameStatus === null) {\n    sprite.hitPoints--;\n    this.score += Math.round(100000 * Math.random());\n    document.getElementById(\"score\").innerHTML = `Score: ${this.score}`;\n    sprite.hit = true;\n    this.sound.play(\"enemyDamage\");\n    if (sprite.hitPoints <= 0) {\n      this.gameStatus = \"won\";\n      this.music[0].stop();\n      this.music[1].stop();\n      this.music[2].stop();\n      this.music[3].play();\n    }\n  } else if (type === \"friendly-bullet\" && sprite && sprite.type === \"henchman\" && this.gameStatus === null) {\n    if (sprite.hitPoints > 0) sprite.hitPoints--;\n    this.score += Math.round(100000 * Math.random());\n    document.getElementById(\"score\").innerHTML = `Score: ${this.score}`;\n    sprite.hit = true;\n    this.sound.play(\"enemyDamage\");\n  } else if (type === \"unfriendly-bullet\" && sprite && sprite.type === \"megaman\" && this.gameStatus === null) {\n    sprite.hitPoints--;\n    sprite.hit = true;\n    this.sound.play(\"megamanHurt\");\n    if (sprite.hitPoints <= 0) {\n      this.gameStatus = \"lost\";\n    }\n  }\n};\n\nfunction trackKeys(codes) {\n  let pressed = {};\n  function handler(event) {\n    if (codes.hasOwnProperty(event.keyCode)) {\n      let down = event.type === \"keydown\";\n      pressed[codes[event.keyCode]] = down;\n      event.preventDefault();\n    }\n  }\n  addEventListener(\"keydown\", handler);\n  addEventListener(\"keyup\", handler);\n  return pressed;\n}\n\nfunction runAnimation(frameFunc) {\n  let lastTime = null;\n  function frame(time) {\n    let stop = false;\n    if (lastTime !== null) {\n      let timeStep = Math.min(time - lastTime, 100) / 1000;\n      stop = (frameFunc(timeStep) === false);\n    }\n    lastTime = time;\n    if (!stop)\n      window.animation = requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n}\n\nlet arrows = trackKeys(arrowCodes);\n\nfunction start(level, Canvas) {\n  let display = new Canvas(document.body, level);\n  window.display = display;\n  let runGame = () => {\n    runAnimation(function(step) {\n      level.animate(step, arrows);\n      display.drawFrame(step);\n      return !window.pause;\n    });\n  };\n  return runGame;\n}\n\nexport function play(plans, Canvas, soundSprites, music) {\n  return start(new Game(plans[0], soundSprites, music), Canvas);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/game.js","export function VectorUtil(x, y) {\n  this.x = x; this.y = y;\n}\nVectorUtil.prototype.plus = function(other) {\n  return new VectorUtil(this.x + other.x, this.y + other.y);\n};\nVectorUtil.prototype.times = function(factor) {\n  return new VectorUtil(this.x * factor, this.y * factor);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/vector_util.js","import { VectorUtil } from './vector_util';\n\nlet gravity = 45;\nlet jumpSpeed = 18;\nlet megamanXSpeed = 6;\nlet bossFiringRate =  4 / 3;\nlet megamanFiringRate = 1 / 3;\n\nexport function Henchman(pos) {\n  this.pos = pos.plus(new VectorUtil(0, 0));\n  this.size = new VectorUtil(1, 1);\n  this.speed = new VectorUtil(0, 0);\n  this.hitPoints = 20;\n  this.lastFire = new Date();\n  this.hit = false;\n  this.destroyed = false;\n}\n\nHenchman.prototype.type = \"henchman\";\n\nHenchman.prototype.moveY = function(step, game) {\n  this.speed.y += step * gravity;\n  let motion = new VectorUtil(0, this.speed.y * step);\n  let newPos = this.pos.plus(motion);\n  let collidedObject = game.findCollision(newPos, this.size);\n  if (collidedObject) {\n    game.spriteOverlapAction(collidedObject);\n    if (this.hitPoints > 0 && this.speed.y > 0) {\n      this.speed.y = 0;\n      this.speed.y = -(Math.random() * (20 - 5) + 5);\n    } else {\n      this.speed.y = 0;\n    }\n  } else {\n    this.pos = newPos;\n  }\n};\n\nHenchman.prototype.act = function(step, game) {\n  this.moveY(step, game);\n\n  // this will slow down the firing rate to 3 a second\n  if (!this.destroyed) {\n    let cFire = new Date();\n    if (((cFire - this.lastFire) / 1000) > bossFiringRate && this.pos.x - game.megaman.pos.x < 17){\n      let fireRight = true;\n      if (this.pos.x > game.megaman.pos.x) fireRight = false;\n      game.sprites.push(new Bullet(new VectorUtil(this.pos.x, this.pos.y), \"unfriendly-bullet\", fireRight));\n      this.lastFire = cFire;\n    }\n  }\n\n  let otherSprite = game.findOverlappingObject(this);\n  if (otherSprite) {\n    game.spriteOverlapAction(otherSprite.type, otherSprite, this);\n  } else {\n    this.hit = false;\n  }\n};\n\nexport function Boss(pos) {\n  this.pos = pos.plus(new VectorUtil(0, 0));\n  this.size = new VectorUtil(1, 1);\n  this.speed = new VectorUtil(0, 0);\n  this.hitPoints = 100;\n  this.lastFire = new Date();\n  this.hit = false;\n  this.destroyed = false;\n}\n\nBoss.prototype.type = \"boss\";\n\nBoss.prototype.moveY = function(step, game) {\n  this.speed.y += step * gravity;\n  let motion = new VectorUtil(0, this.speed.y * step);\n  let newPos = this.pos.plus(motion);\n  let collidedObject = game.findCollision(newPos, this.size);\n  if (collidedObject) {\n    game.spriteOverlapAction(collidedObject);\n    if (this.hitPoints > 0 && this.speed.y > 0) {\n      this.speed.y = 0;\n      this.speed.y = -(Math.random() * (20 - 5) + 5);\n    } else {\n      this.speed.y = 0;\n    }\n  } else {\n    this.pos = newPos;\n  }\n};\n\nBoss.prototype.act = function(step, game) {\n  this.moveY(step, game);\n\n  // this will slow down the firing rate to 3 a second\n  if (!this.destroyed) {\n    let cFire = new Date();\n    if (((cFire - this.lastFire) / 1000) > bossFiringRate && this.pos.x - game.megaman.pos.x < 23){\n      let fireRight = true;\n      if (this.pos.x > game.megaman.pos.x) fireRight = false;\n      game.sprites.push(new Bullet(new VectorUtil(this.pos.x, this.pos.y), \"unfriendly-bullet\", fireRight));\n      this.lastFire = cFire;\n    }\n  }\n\n  let otherSprite = game.findOverlappingObject(this);\n  if (otherSprite) {\n    game.spriteOverlapAction(otherSprite.type, otherSprite, this);\n  } else {\n    this.hit = false;\n  }\n\n  if (game.gameStatus === \"won\") {\n    this.destroyed = true;\n  }\n};\n\nexport function Bullet(pos, bulletType, fireRight) {\n  this.pos = pos.plus(new VectorUtil(0, 0));\n  this.size = new VectorUtil(1, 1);\n  if (fireRight === true) {\n    this.speed = new VectorUtil(10, 0);\n  } else if (fireRight === false) {\n    this.speed = new VectorUtil(-10, 0);\n  } else if (window.display.facingRight) {\n    this.speed = new VectorUtil(-10, 0);\n  } else {\n    this.speed = new VectorUtil(10, 0);\n  }\n  this.type = bulletType;\n}\n\nBullet.prototype.moveX = function(step, game, keys) {\n  let motion = new VectorUtil(this.speed.x * step, 0);\n  let newPos = this.pos.plus(motion);\n  this.pos = newPos;\n};\n\nBullet.prototype.act = function(step, game) {\n  this.moveX(step, game);\n};\n\nexport function Megaman(pos) {\n  this.pos = pos.plus(new VectorUtil(0, 0));\n  this.size = new VectorUtil(1, 1);\n  this.speed = new VectorUtil(0, 0);\n  this.lastFire = new Date();\n  this.hitPoints = 50;\n  this.hit = false;\n}\n\nMegaman.prototype.type = \"megaman\";\n\nMegaman.prototype.moveX = function(step, game, keys) {\n  this.speed.x = 0;\n  if (keys.left) this.speed.x -= megamanXSpeed;\n  if (keys.right) this.speed.x += megamanXSpeed;\n\n  let motion = new VectorUtil(this.speed.x * step, 0);\n  let newPos = this.pos.plus(motion);\n  let collidedObject = game.findCollision(newPos, this.size);\n  if (collidedObject) {\n    game.spriteOverlapAction(collidedObject);\n  } else if (this.hitPoints > 0) {\n    this.hit = false;\n    this.pos = newPos;\n  }\n};\n\nMegaman.prototype.moveY = function(step, game, keys) {\n  this.speed.y += step * gravity;\n  let motion = new VectorUtil(0, this.speed.y * step);\n  let newPos = this.pos.plus(motion);\n  let collidedObject = game.findCollision(newPos, this.size);\n  if (collidedObject) {\n    game.spriteOverlapAction(collidedObject);\n    if (keys.up && this.speed.y > 0) {\n      this.speed.y = -jumpSpeed;\n    } else {\n      this.speed.y = 0;\n    }\n  } else if (this.hitPoints > 0) {\n    this.pos = newPos;\n  }\n};\n\nMegaman.prototype.act = function(step, game, keys) {\n  this.moveX(step, game, keys);\n  this.moveY(step, game, keys);\n  if (keys.shoot && this.hitPoints > 0) {\n    // this will slow down the firing rate to 3 a second\n    let cFire = new Date();\n    if (((cFire - this.lastFire) / 1000) > megamanFiringRate){\n      game.sound.play(\"shoot\");\n      game.sprites.push(new Bullet(new VectorUtil(this.pos.x, this.pos.y), \"friendly-bullet\"));\n      this.lastFire = cFire;\n    }\n  }\n\n  let otherSprite = game.findOverlappingObject(this);\n  if (otherSprite) {\n    game.spriteOverlapAction(otherSprite.type, otherSprite, this);\n  }\n\n  // Losing animation\n  if (game.gameStatus === \"lost\") {\n    this.hit = true;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/sprites.js","export let levels = [\n  [\"                                                                                \",\n   \"                                                                                \",\n   \"                                                                                \",\n   \"                                                                                \",\n   \"                                                                                \",\n   \"                                                                           B    \",\n   \"                                                     H     #####################\",\n   \"                                                   #####                        \",\n   \"                                       H    ####                                \",\n   \"                                 H   ####                                       \",\n   \"                         H    #####                     ####     ####   ####    \",\n   \"                   H   ####                 ####   ##                           \",\n   \"     M           ####               ####                                        \",\n   \"WW############WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\",\n   \"                                                                                \",]\n ];\n\n\n\n// WEBPACK FOOTER //\n// ./lib/levels.js","let spriteSize = 50;\nlet spriteRoll = document.createElement(\"img\");\nspriteRoll.src = \"images/megaman.png\";\n\nfunction flipHorizontally(context, around) {\n  context.translate(around, 0);\n  context.scale(-1, 1);\n  context.translate(-around, 0);\n}\n\nexport function Canvas(parent, game) {\n  this.canvas = document.createElement(\"canvas\");\n  this.canvas.id = \"canvas\";\n  this.canvas.width = Math.min(window.innerWidth, game.width * spriteSize);\n  this.canvas.height = Math.min(window.innerWidth / 3, game.height * spriteSize);\n  parent.appendChild(this.canvas);\n  this.cx = this.canvas.getContext(\"2d\");\n\n  this.game = game;\n  this.animationTime = 0;\n  this.facingRight = false;\n\n  this.viewport = {\n    top: 0,\n    left: 0,\n    height: this.canvas.height / spriteSize,\n    width: this.canvas.width / spriteSize\n  };\n\n  this.start = new Date();\n  this.drawFrame(0);\n}\n\nCanvas.prototype.clear = function() {\n  this.canvas.parentNode.removeChild(this.canvas);\n};\n\nCanvas.prototype.drawFrame = function(step) {\n  this.animationTime += step;\n\n  this.updateViewport();\n  this.clearDisplay();\n  this.drawBackground();\n  this.drawSprites();\n};\n\nCanvas.prototype.updateViewport = function() {\n  let view = this.viewport, margin = view.width / 6;\n  let megaman = this.game.megaman;\n  let center = megaman.pos.plus(megaman.size.times(0.5));\n\n  if (center.x < view.left + margin * 2) {\n    view.left = Math.max(center.x - margin * 2, 0);\n  }  else if (center.x > view.left + view.width - margin * 2) {\n    view.left = Math.min(center.x + margin * 2 - view.width, this.game.width - view.width);\n  }\n\n  if (center.y < view.top + margin) {\n    view.top = Math.max(center.y - margin, 0);\n  }  else if (center.y > view.top + view.height - margin) {\n    view.top = Math.min(center.y + margin - view.height, this.game.height - view.height);\n  }\n};\n\nCanvas.prototype.clearDisplay = function() {\n  this.cx.fillStyle = \"lightblue\";\n  // Don't forget to make things transparent!\n  this.cx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n};\n\nCanvas.prototype.drawBackground = function() {\n  let view = this.viewport;\n  let left = Math.floor(view.left);\n  let right = Math.ceil(view.left + view.width);\n  let top = Math.floor(view.top);\n  let bottom = Math.ceil(view.top + view.height);\n\n  for (let y = top; y < bottom; y++) {\n    for (let x = left; x < right; x++) {\n      let fieldType = this.game.grid[y][x];\n      if (fieldType === null) continue;\n      let xPosition = (x - view.left) * spriteSize;\n      let yPosition = (y - view.top) * spriteSize;\n\n      let spriteFrameNumber;\n      if (fieldType === \"water\") spriteFrameNumber = 16;\n      if (fieldType === \"block\") spriteFrameNumber = 15;\n\n      this.cx.drawImage(\n        spriteRoll,\n        (spriteFrameNumber * spriteSize), 0, spriteSize, spriteSize,\n        xPosition, yPosition, spriteSize, spriteSize\n      );\n    }\n  }\n\n  let farewellMessage = document.createElement(\"img\");\n  farewellMessage.src = \"images/win-loss.png\";\n  let messageNumber;\n\n  if (this.game.gameStatus === \"lost\") {\n    messageNumber = 1;\n    this.cx.drawImage(\n      farewellMessage,\n      (messageNumber * 400), 0,\n      400, 200,\n      750 + (right - left) / 2, 150 + (bottom - top) / 2,\n      400, 200\n    );\n  } else if (this.game.gameStatus === \"won\") {\n    messageNumber = 0;\n    this.cx.drawImage(\n      farewellMessage,\n      (messageNumber * 400), 0,\n      400, 200,\n      750 + (right - left) / 2, 150 + (bottom - top) / 2,\n      400, 200\n    );\n  } else if (new Date() - this.start < 7000) {\n    messageNumber = 2;\n    this.cx.drawImage(\n      farewellMessage,\n      (messageNumber * 400), 0,\n      400, 200,\n      750 + (right - left) / 2, 150 + (bottom - top) / 2,\n      400, 200\n    );\n  }\n};\n\nCanvas.prototype.drawMegaMan = function(x, y, width, height) {\n  let spriteFrameNumber = 0;\n  let megaman = this.game.megaman;\n\n  if (megaman.hitPoints > 0 && megaman.hitPoints < 50) megaman.hitPoints += 0.02;\n\n  document.getElementById(\"megaman-health\").innerHTML = `Megaman Health: ${Math.round(megaman.hitPoints)}`;\n\n  if (megaman.speed.x !== 0) this.facingRight = megaman.speed.x < 0;\n\n  if (megaman.hit) {\n    spriteFrameNumber = 14;\n  } else if (megaman.speed.y !== 0) {\n    spriteFrameNumber = 11;\n  } else if (megaman.speed.x !== 0) {\n    spriteFrameNumber = Math.floor(this.animationTime * 12) % 10 + 1;\n  }\n\n  let rectangle = new Path2D();\n  rectangle.rect(x, y - 20, 50 * megaman.hitPoints / 50, 20);\n  this.cx.stroke(rectangle);\n  this.cx.save(); //keep drawing context intact\n\n  if (this.facingRight) flipHorizontally(this.cx, x + width / 2);\n  this.cx.drawImage(\n    spriteRoll,\n    (spriteFrameNumber * width), 0,\n    width, height,\n    x, y, width, height\n  );\n\n  this.cx.restore(); //restore drawing context\n\n};\n\nCanvas.prototype.drawBoss = function(x, y, width, height) {\n  let spriteFrameNumber = 13;\n  let boss = this.game.boss;\n  if (boss.destroyed) {\n    spriteFrameNumber = [17, 18][Math.floor(Math.random() * [17, 18].length)];\n  } else if (boss.hit) {\n    spriteFrameNumber = [17, 18][Math.floor(Math.random() * [17, 18].length)];\n  }\n\n  if (!boss.destroyed && boss.hitPoints < 100) boss.hitPoints += 0.02;\n  document.getElementById(\"boss-health\").innerHTML = `Boss Health: ${Math.round(boss.hitPoints)}`;\n\n  if (!boss.destroyed) {\n    let rectangle = new Path2D();\n    rectangle.rect(x, y - 20, 50 * boss.hitPoints / 50, 20);\n    this.cx.stroke(rectangle);\n  }\n\n  this.cx.save(); //keep drawing context intact\n  if (this.game.megaman.pos.x > this.game.boss.pos.x) flipHorizontally(this.cx, x + width / 2);\n\n  this.cx.drawImage(\n    spriteRoll,\n    (spriteFrameNumber * width), 0,\n    width, height,\n    x, y, width, height\n  );\n\n  this.cx.restore(); //restore drawing context\n};\n\nCanvas.prototype.drawHenchman = function(x, y, width, height, henchman) {\n  if (!henchman.destroyed) {\n    let spriteFrameNumber = 20;\n    if (henchman.hitPoints <= 0) henchman.destroyed = true;\n    if (henchman.hit) {\n      spriteFrameNumber = [17, 20][Math.floor(Math.random() * [17, 20].length)];\n    }\n\n    let rectangle = new Path2D();\n    rectangle.rect(x, y - 20, 45 * henchman.hitPoints / 20, 20);\n    this.cx.stroke(rectangle);\n\n    this.cx.save(); //keep drawing context intact\n    if (this.game.megaman.pos.x > henchman.pos.x) flipHorizontally(this.cx, x + width / 2);\n\n\n    this.cx.drawImage(\n      spriteRoll,\n      (spriteFrameNumber * width), 0,\n      width, height,\n      x, y, width, height\n    );\n\n    this.cx.restore(); //restore drawing context\n  }\n};\n\nCanvas.prototype.drawBullet = function(x, y, width, height) {\n  let spriteFrameNumber = 12;\n  this.cx.drawImage(\n    spriteRoll,\n    (spriteFrameNumber * width), 0,\n    width, height,\n    x, y, width, height\n  );\n};\n\nCanvas.prototype.drawSprites = function() {\n  this.game.sprites.forEach(function(sprite) {\n    let width = sprite.size.x * spriteSize;\n    let height = sprite.size.y * spriteSize;\n    let x = (sprite.pos.x - this.viewport.left) * spriteSize;\n    let y = (sprite.pos.y - this.viewport.top) * spriteSize;\n    if (sprite.type === \"megaman\") {\n      this.drawMegaMan(x, y, width, height);\n    } else if (sprite.type === \"boss\"){\n      this.drawBoss(x, y, width, height);\n    } else if (sprite.type === \"henchman\"){\n      this.drawHenchman(x, y, width, height, sprite);\n    } else if (sprite.type === \"friendly-bullet\"){\n      this.drawBullet(x, y, width, height);\n    } else if (sprite.type === \"unfriendly-bullet\"){\n      this.drawBullet(x, y, width, height);\n    }\n  }, this);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lib/canvas.js","import { Howl } from 'howler';\n\nlet musicChibi = new Howl({\n  src: 'sounds/music/chibi.mp3',\n  autoplay: false,\n  loop: true,\n  volume: 1,\n});\n\nlet musicDigital = new Howl({\n  src: 'sounds/music/digital.mp3',\n  autoplay: false,\n  loop: true,\n  volume: 1,\n});\n\nlet musicResistors = new Howl({\n  src: 'sounds/music/resistors.mp3',\n  autoplay: false,\n  loop: true,\n  volume: 1,\n});\n\nlet victory = new Howl({\n  src: 'sounds/music/boss_defeated.mp3',\n  autoplay: false,\n  loop: false,\n  volume: 1,\n});\n\nexport const music = [musicChibi, musicDigital, musicResistors, victory];\n\nexport const soundSprites = new Howl({\n  src: ['sounds/fx/sound_sprites.mp3'],\n  sprite: {\n    explosion: [0, 500],\n    enemyDamage: [0, 500],\n    megamanHurt: [0, 500],\n    jump: [1300, 100],\n    shoot: [1400, 250]\n  }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./lib/sound.js","/*!\n *  howler.js v2.0.2\n *  howlerjs.com\n *\n *  (c) 2013-2016, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto iOS enabler.\n      self.mobileAutoEnable = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.value = vol;\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.value = muted ? 0 : self._volume;\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'running' : 'running';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Mobile browsers will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _enableMobileAudio: function() {\n      var self = this || Howler;\n\n      // Only run this on mobile devices if audio isn't already eanbled.\n      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);\n      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));\n      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {\n        return;\n      }\n\n      self._mobileEnabled = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function() {\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._mobileEnabled = true;\n          self.mobileAutoEnable = false;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchend', unlock, true);\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchend', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n        self.ctx.suspend().then(function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        });\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended') {\n        self.state = 'resuming';\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio on iOS.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {\n        Howler._enableMobileAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload) {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Check if this extension is available.\n        if (Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        var num = 0;\n        for (var i=0; i<self._sounds.length; i++) {\n          if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n            num++;\n            id = self._sounds[i]._id;\n          }\n        }\n\n        if (num === 1) {\n          sprite = null;\n        } else {\n          id = null;\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If we have no sprite and the sound hasn't loaded, we must wait\n      // for the sound to load to get our audio's duration.\n      if (self._state !== 'loaded' && !self._sprite[sprite]) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(self._soundById(sound._id) ? sound._id : undefined);\n          }\n        });\n\n        return sound._id;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          setTimeout(function() {\n            self._emit('play', sound._id);\n          }, 0);\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n      // Update the parameters of the sound\n      sound._paused = false;\n      sound._ended = false;\n      sound._sprite = sprite;\n      sound._seek = seek;\n      sound._start = self._sprite[sprite][0] / 1000;\n      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n            }, 0);\n          }\n        };\n\n        var isRunning = (Howler.state === 'running');\n        if (self._state === 'loaded' && isRunning) {\n          playWebAudio();\n        } else {\n          // Wait for the audio to load and then begin playback.\n          self.once(isRunning ? 'load' : 'resume', playWebAudio, isRunning ? sound._id : null);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          setTimeout(function() {\n            node.play();\n\n            // Setup the new end timer.\n            if (timeout !== Infinity) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            if (!internal) {\n              self._emit('play', sound._id);\n            }\n          }, 0);\n        };\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));\n        if (node.readyState === 4 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          var listener = function() {\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // make sure the sound has been created\n              if (!sound._node.bufferSource) {\n                return self;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // make sure the sound has been created\n              if (!sound._node.bufferSource) {\n                if (!internal) {\n                  self._emit('stop', sound._id);\n                }\n\n                return self;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n            }\n          }\n        }\n\n        if (sound && !internal) {\n          self._emit('stop', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n      var diff = Math.abs(from - to);\n      var dir = from > to ? 'out' : 'in';\n      var steps = diff / 0.01;\n      var stepLen = (steps > 0) ? len / steps : len;\n\n      // Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.\n      if (stepLen < 4) {\n        steps = Math.ceil(steps / (4 / stepLen));\n        stepLen = 4;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          var vol = from;\n          sound._interval = setInterval(function(soundId, sound) {\n            // Update the volume amount, but only if the volume should change.\n            if (steps > 0) {\n              vol += (dir === 'in' ? 0.01 : -0.01);\n            }\n\n            // Make sure the volume is in the right bounds.\n            vol = Math.max(0, vol);\n            vol = Math.min(1, vol);\n\n            // Round to within 2 decimal points.\n            vol = Math.round(vol * 100) / 100;\n\n            // Change the volume.\n            if (self._webAudio) {\n              if (typeof id === 'undefined') {\n                self._volume = vol;\n              }\n\n              sound._volume = vol;\n            } else {\n              self.volume(vol, soundId, true);\n            }\n\n            // When the fade is complete, stop it and fire event.\n            if (vol === to) {\n              clearInterval(sound._interval);\n              sound._interval = null;\n              self.volume(vol, soundId);\n              self._emit('fade', soundId);\n            }\n          }.bind(self, ids[i], sound), stepLen);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            sound._rateSeek = self.seek(id[i]);\n            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.value = rate;\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return self;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Restart the playback if the sound was playing.\n          if (playing) {\n            self.play(id, true);\n          }\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node) {\n            sound._node.currentTime = seek;\n          }\n\n          self._emit('seek', id);\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n          self._emit('end', sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading.\n          sounds[i]._node.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n\n        // Remove the references in the global Howler object.\n        var index = Howler._howls.indexOf(self);\n        if (index >= 0) {\n          Howler._howls.splice(index, 1);\n        }\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      if (fn) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          if (fn === events[i].fn && id === events[i].id) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function() {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // don't move onto the next task until this one is done\n        self.once(task.event, function() {\n          self._queue.shift();\n          self._loadQueue();\n        });\n\n        task.action();\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        clearTimeout(self._endTimers[id]);\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop;\n      }\n      sound._node.bufferSource.playbackRate.value = sound._rate;\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n\n      if (self._scratchBuffer) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}\n      }\n      node.bufferSource = null;\n\n      return self;\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._muted = parent._muted;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = Math.round(Date.now() * Math.random());\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else {\n        self._node = new Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = 'auto';\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._muted = parent._muted;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = Math.round(Date.now() * Math.random());\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorListener, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Decode the buffer into an audio source.\n    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      }\n    }, function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    });\n  };\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.value = 1;\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    });\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (typeof exports !== 'undefined') {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Define globally in case AMD is not available or unused.\n  if (typeof window !== 'undefined') {\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.0.2\n *  howlerjs.com\n *\n *  (c) 2013-2016, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n  \n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              sound._panner.setPosition(pan, 0, 0);\n            } else {\n              sound._panner.pan.value = pan;\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or\n   * all in the group. The most common usage is to set the 'x' position for\n   * left/right panning. Setting any value higher than 1.0 will begin to\n   * decrease the volume of the sound as it moves further away.\n   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setPosition(x, y, z);\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setOrientation(x, y, z);\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.\n   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of\n   *                      `coneOuterGain` outside this angle.\n   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.\n   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves\n   *                      away from listener. Can be `linear`, `inverse` or `exponential`.\n   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *     refDistance - (1 by default) A reference distance for reducing volume as the source\n   *                    moves away from the listener.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.\n   * \n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,\n            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,\n            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,\n            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,\n            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.panningModel = pa.panningModel;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.value = sound._stereo;\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id);\n    }\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/howler/dist/howler.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}